<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript Constructor & new Operator</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gradient-to-br from-gray-100 to-gray-200 min-h-screen font-sans leading-relaxed text-gray-800">
    <header
        class="sticky top-0 z-50 bg-gradient-to-r from-blue-600 to-indigo-600 text-white shadow-lg py-6 text-center">
        <h1 class="text-3xl font-bold animate-pulse mb-2">üõ†Ô∏è JavaScript Constructor & new Operator</h1>
    </header>

    <main class="pt-10 px-6 max-w-6xl mx-auto space-y-10">
        <section class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4">üîß What is a Constructor Function?</h2>
            <p>
                In JavaScript, a constructor function is a regular function used to create multiple similar objects. By
                convention, constructor function names start with a capital letter and are invoked using the
                <code>new</code> operator.
            </p>
            <pre class="bg-gray-100 p-4 rounded mt-4"><code>function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");
console.log(user.name); // Jack
console.log(user.isAdmin); // false</code></pre>
        </section>

        <section class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4">‚öôÔ∏è How the <code>new</code> Operator Works</h2>
            <p>
                When a function is called with the <code>new</code> operator, the following steps occur:
            </p>
            <ol class="list-decimal list-inside mt-4 space-y-2">
                <li>A new empty object is created and assigned to <code>this</code>.</li>
                <li>The function body executes, modifying <code>this</code> by adding properties.</li>
                <li>The value of <code>this</code> is returned implicitly.</li>
            </ol>
            <p class="mt-4">
                This process allows for the creation of multiple objects with similar structures and behaviors.
            </p>
        </section>

        <section class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4">üß™ Using <code>new.target</code> to Detect Constructor Calls</h2>
            <p>
                The <code>new.target</code> meta-property allows functions to detect whether they were called with the
                <code>new</code> operator.
            </p>
            <pre class="bg-gray-100 p-4 rounded mt-4"><code>function User(name) {
  if (!new.target) {
    return new User(name);
  }
  this.name = name;
}

let user = User("Alice");
console.log(user.name); // Alice</code></pre>
            <p class="mt-4">
                This pattern ensures that the function behaves correctly whether or not <code>new</code> is used.
            </p>
        </section>

        <section class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4">üîÑ Behavior of <code>return</code> in Constructors</h2>
            <p>
                In JavaScript, the behavior of the <code>return</code> statement in constructor functions varies based
                on the returned value:
            </p>
            <ul class="list-disc list-inside mt-4 space-y-2">
                <li><strong>Returning an object:</strong> If a constructor explicitly returns an object, that object
                    becomes the result of the <code>new</code> expression.</li>
                <li><strong>Returning a primitive:</strong> If a primitive value (e.g., number, string) is returned, it
                    is ignored, and the newly created object (<code>this</code>) is returned instead.</li>
                <li><strong>No return statement:</strong> If no return statement is present, the constructor returns the
                    newly created object (<code>this</code>) by default.</li>
            </ul>
            <pre class="bg-gray-100 p-4 rounded mt-4"><code>function User(name) {
  this.name = name;
  return { greeting: "Hello" };
}

let user = new User("Alice");
console.log(user.greeting); // "Hello"</code></pre>
            <p class="mt-4">
                In the example above, the constructor returns an explicit object, so <code>user</code> is assigned that
                object instead of the default <code>this</code>.
            </p>
        </section>

        <section class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4">üß∞ Defining Methods Inside Constructors</h2>
            <p>
                Methods can be defined inside constructor functions by assigning them directly to the instance using
                <code>this</code>. This approach creates a new function for each instance, which can be beneficial for
                encapsulation but may have memory implications.
            </p>
            <pre class="bg-gray-100 p-4 rounded mt-4"><code>function User(name) {
  this.name = name;
  this.sayHi = function() {
    console.log("Hi, I'm " + this.name);
  };
}

let user1 = new User("Bob");
user1.sayHi(); // "Hi, I'm Bob"</code></pre>
            <p class="mt-4">
                Alternatively, methods can be added to the constructor's prototype, allowing all instances to share the
                same function, which is more memory-efficient.
            </p>
            <pre class="bg-gray-100 p-4 rounded mt-4"><code>function User(name) {
  this.name = name;
}

User.prototype.sayHi = function() {
  console.log("Hi, I'm " + this.name);
};

let user2 = new User("Carol");
user2.sayHi(); // "Hi, I'm Carol"</code></pre>
        </section>
        
        <section class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-2xl font-semibold mb-4">üß† Considerations for Senior/Lead Developers</h2>
            <ul class="list-disc list-inside mt-4 space-y-2">
                <li><strong>Prototype Management:</strong> Ensure that the <code>prototype</code> property of
                    constructor functions is correctly set to enable proper inheritance.</li>
                <li><strong>Consistent Usage:</strong> Enforce the use of the <code>new</code> operator with constructor
                    functions to prevent unexpected behaviors.</li>
                <li><strong>Code Readability:</strong> Use clear and descriptive names for constructor functions to
                    improve code maintainability.</li>
                <li><strong>Modern Alternatives:</strong> Consider using ES6 classes for clearer syntax and better
                    structure in object-oriented code.</li>
            </ul>
        </section>
    </main>

    <footer class="text-center text-sm text-gray-600 py-4 border-t border-gray-300 mt-10">
        &copy; 2025 Made by <strong>CAMNV</strong>. All rights reserved.
    </footer>
</body>

</html>